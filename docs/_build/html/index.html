
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Pascal Manual &#8212; pascal 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="#">pascal 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Pascal Manual</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="pascal-manual">
<h1>Pascal Manual<a class="headerlink" href="#pascal-manual" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Pasccal is an algorithm for learning probabilistic integrity constraints. It was
proposed in <a class="reference internal" href="#rigbelzesalblam21-ml-ij" id="id1">[RBZ+21]</a>.
It contains modules for both structure and parameter learning.</p>
<p>Pascal is also available in the cplint on SWISH web application at <a class="reference external" href="http://cplint.eu">http://cplint.eu</a>.</p>
</section>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>Pascal is distributed as a <a class="reference external" href="http://www.swi-prolog.org/pack/list?p=pack">pack</a> of <a class="reference external" href="http://www.swi-prolog.org/">SWI-Prolog</a>.
To install it, use</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">pack_install</span><span class="p">(</span><span class="s s-Atom">pack</span><span class="p">).</span>
</pre></div>
</div>
<section id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<p>It requires the pack</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://github.com/friguzzi/lbfgs">lbfgs</a></p></li>
</ul>
</div></blockquote>
<p>It is installed automatically when installing pack <cite>pascal</cite> or can be installed manually as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ swipl
?- pack_install(lbfgs).
</pre></div>
</div>
<p><cite>lbfgs</cite> uses a foreign library and contains the library binaries for 32 and 64 bits Linux. If you want to recompile the foreign library you can use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- pack_rebuild(lbfgs).
</pre></div>
</div>
<p>On 32 and 64 bits Linux this should work out of the box.</p>
<p>You can upgrade the pack with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ swipl
?- pack_upgrade(pack).
</pre></div>
</div>
<p>Note that the pack on which <cite>pascal</cite> depends is not upgraded automatically in this case so it needs to be upgraded manually.</p>
</section>
<section id="example-of-use">
<h3>Example of use<a class="headerlink" href="#example-of-use" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd &lt;pack&gt;/pascal/prolog/examples
$ swipl
?- [bongardkeys].
?- induce_pascal([train]),T).
</pre></div>
</div>
</section>
<section id="testing-the-installation">
<h3>Testing the installation<a class="headerlink" href="#testing-the-installation" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ swipl
?- [library(test_pascal)].
?- test_pascal.
</pre></div>
</div>
</section>
<section id="support">
<h3>Support<a class="headerlink" href="#support" title="Permalink to this headline">¶</a></h3>
<p>Use the Google group <a class="reference external" href="https://groups.google.com/forum/#!forum/cplint">https://groups.google.com/forum/#!forum/cplint</a>.</p>
</section>
</section>
<section id="language">
<h2>Language<a class="headerlink" href="#language" title="Permalink to this headline">¶</a></h2>
<p>A Probabilistic Constraint Logic Theory (PCLT) is a set of Probabilistic Integrity Constraints (PIC) of the form</p>
<div class="math notranslate nohighlight">
\[p \ ::\ L_1,\ldots,L_b\rightarrow \exists(P_1);\ldots;\exists(P_n);\forall\neg(N_1);\ldots;\forall\neg(N_m)\]</div>
<p>where <span class="math notranslate nohighlight">\(p\)</span> is a probability, each <span class="math notranslate nohighlight">\(L_i\)</span> is a literal and each <span class="math notranslate nohighlight">\(P_j\)</span> and <span class="math notranslate nohighlight">\(N_j\)</span> is a conjunction of literals.
We  call each <span class="math notranslate nohighlight">\(P_j\)</span>  a <em>P conjunction</em>  and  each <span class="math notranslate nohighlight">\(N_k\)</span> an
<em>N conjunction</em>.  We  call each
<span class="math notranslate nohighlight">\(\exists(P_j)\)</span> a <em>P disjunct</em> and each <span class="math notranslate nohighlight">\(\forall\neg(N_k)\)</span> an <em>N disjunct</em>.</p>
<p>The variables that occur in the body are quantified universally with
scope the PIC. The variables in the head that do not occur in the body
are quantified existentially if they occur in a P disjunct and
universally if they occur in an N disjunct, with scope the disjunct
they occur in.</p>
<p>An example of a PIC for the Bongard problems of <a class="reference internal" href="#raelae95-alt95" id="id2">[DRVL95]</a></p>
<div class="math notranslate nohighlight" id="example-of-a-pic">
\[0.5\ ::\ triangle(T),square(S),in(T,S)\rightarrow \exists(circle(C),in(C,S));\forall\neg(circle(C),in(C,T))\]</div>
<p>which states
that if there is a triangle inside a square then either there exists a circle inside the square or
there doesn’t exist a circle inside the triangle. This constraint
has probability 0.5.</p>
</section>
<section id="use">
<h2>Use<a class="headerlink" href="#use" title="Permalink to this headline">¶</a></h2>
<p>The following learning algorithms are available:</p>
<ul class="simple">
<li><p>Parameter learning</p></li>
<li><p>Structure learning</p></li>
</ul>
<section id="input">
<h3>Input<a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h3>
<p>To execute the learning algorithms, prepare a Prolog file divided in five parts</p>
<ul class="simple">
<li><p>preamble</p></li>
<li><p>background knowledge, i.e., knowledge valid for all interpretations</p></li>
<li><p>PCLT for you which you want to learn the parameters (optional)</p></li>
<li><p>language bias information</p></li>
<li><p>example interpretations</p></li>
</ul>
<p>The preamble must come first, the order of the other parts can be changed.</p>
<p>For example, consider the Bongard problems of <a class="reference internal" href="#raelae95-alt95" id="id3">[DRVL95]</a>.
<a class="reference external" href="http://cplint.eu/example/pascal/bongardkeys.pl">bongardkeys.pl</a> represents a Bongard problem for Pascal.</p>
<section id="preamble">
<h4>Preamble<a class="headerlink" href="#preamble" title="Permalink to this headline">¶</a></h4>
<p>In the preamble, the Pascal library is loaded with (<a class="reference external" href="http://cplint.eu/e/pascal/bongardkeys.pl">bongardkeys.pl</a>):</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">pascal</span><span class="p">)).</span>
</pre></div>
</div>
<p>Now you can initialize pascal with</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="s s-Atom">pascal</span><span class="p">.</span>
</pre></div>
</div>
<p>At this point you can start setting parameters for Pascal such as for example</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span><span class="nf">set_pascal</span><span class="p">(</span><span class="s s-Atom">examples</span><span class="p">,</span><span class="nf">keys</span><span class="p">(</span><span class="s s-Atom">pos</span><span class="p">)).</span>
<span class="p">:-</span><span class="nf">set_pascal</span><span class="p">(</span><span class="s s-Atom">learning_algorithm</span><span class="p">,</span><span class="s s-Atom">gradient_descent</span><span class="p">).</span>
<span class="p">:-</span><span class="nf">set_pascal</span><span class="p">(</span><span class="s s-Atom">learning_rate</span><span class="p">,</span><span class="nf">fixed</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)).</span>
<span class="p">:-</span><span class="nf">set_pascal</span><span class="p">(</span><span class="s s-Atom">verbosity</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<p>We will see later the list of available parameters.</p>
<p>A parameter that is particularly important for Pascal is <code class="code docutils literal notranslate"><span class="pre">verbosity</span></code>: if set to 1,
nothing is printed and learning is fastest,
if set to 3 much information is printed and learning is slowest, 2 is in between. This ends the preamble.</p>
</section>
<section id="background-and-initial-pclt">
<h4>Background and Initial PCLT<a class="headerlink" href="#background-and-initial-pclt" title="Permalink to this headline">¶</a></h4>
<p>Now you can specify the background knowledge by including a set of Prolog clauses
in a section between <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">begin_bg.</span></code> and <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">end_bg.</span></code>
For example</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="s s-Atom">begin_bg</span><span class="p">.</span>
<span class="nf">in</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">inside</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">D</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">inside</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">C</span><span class="p">),</span><span class="nf">in</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">).</span>
<span class="p">:-</span> <span class="s s-Atom">end_bg</span><span class="p">.</span>
</pre></div>
</div>
<p>Moreover, you can specify an initial PCLT in a section between <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">begin_in.</span></code> and <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">end_in.</span></code>.
The initial program is used in parameter learning for providing the structure.
In the section, facts for the predicates <code class="code docutils literal notranslate"><span class="pre">rule/2</span></code> or <code class="code docutils literal notranslate"><span class="pre">ic/1</span></code> can be given.</p>
<p>Facts for <code class="code docutils literal notranslate"><span class="pre">rule/2</span></code> take the form <code class="code docutils literal notranslate"><span class="pre">rule(ic,prob)</span></code> where <code class="code docutils literal notranslate"><span class="pre">prob</span></code> is a probability and
<code class="code docutils literal notranslate"><span class="pre">ic</span></code> is a term of the form <code class="code docutils literal notranslate"><span class="pre">head:-body</span></code>. In it, <code class="code docutils literal notranslate"><span class="pre">body</span></code> is a list of literals and <code class="code docutils literal notranslate"><span class="pre">head</span></code>
is a list of head disjuncts. Each head disjunct is couple <code class="code docutils literal notranslate"><span class="pre">(sign,conjunction)</span></code> where sign is
either <code class="code docutils literal notranslate"><span class="pre">(+)</span></code> for P disjuncts or <code class="code docutils literal notranslate"><span class="pre">(-)</span></code> for N disjuncts and <code class="code docutils literal notranslate"><span class="pre">conjunction</span></code> is a list of literals.</p>
<p>The <a class="reference internal" href="#example-of-a-pic">example of a PIC</a> above can be expressed as</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="s s-Atom">begin_in</span><span class="p">.</span>
<span class="nf">rule</span><span class="p">(([((</span><span class="s s-Atom">+</span><span class="p">),[</span><span class="nf">circle</span><span class="p">(</span><span class="nv">C</span><span class="p">),</span><span class="nf">in</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span><span class="nv">S</span><span class="p">)]),((</span><span class="s s-Atom">-</span><span class="p">),[</span><span class="nf">circle</span><span class="p">(</span><span class="nv">C</span><span class="p">),</span><span class="nf">in</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span><span class="nv">T</span><span class="p">)])]:-</span>
  <span class="p">[</span><span class="nf">triangle</span><span class="p">(</span><span class="nv">T</span><span class="p">),</span><span class="nf">square</span><span class="p">(</span><span class="nv">S</span><span class="p">),</span><span class="nf">in</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span><span class="nv">S</span><span class="p">)]),</span><span class="mf">0.5</span><span class="p">).</span>
<span class="p">:-</span> <span class="s s-Atom">end_in</span><span class="p">.</span>
</pre></div>
</div>
<p>Facts for the predicate <code class="code docutils literal notranslate"><span class="pre">ic/1</span></code> take the form <code class="code docutils literal notranslate"><span class="pre">ic(string)</span></code> where <code class="code docutils literal notranslate"><span class="pre">string</span></code> is a Prolog
string wher a constraint is encoded as <code class="code docutils literal notranslate"><span class="pre">prob::body---&gt;head</span></code>.
<code class="code docutils literal notranslate"><span class="pre">body</span></code> is a conjuntion of literals where the conjunction symbol is <code class="code docutils literal notranslate"><span class="pre">/\</span> </code>.
<code class="code docutils literal notranslate"><span class="pre">head</span></code> is a disjunction where the disjunction symbol is <code class="code docutils literal notranslate"><span class="pre">\/</span></code>.
Each disjunct is either a conjunction of literals, in the case of a P disjunct, or of the form
<code class="code docutils literal notranslate"><span class="pre">not(conjunction)</span></code> where <code class="code docutils literal notranslate"><span class="pre">conjunction</span></code> is a conjunction of literals.</p>
<p>The <a class="reference internal" href="#example-of-a-pic">example of a PIC</a> above can be expressed as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">:</span><span class="o">-</span> <span class="n">begin_in</span><span class="o">.</span>
<span class="n">ic</span><span class="p">(</span><span class="s2">&quot;0.5 :: triangle(T)/</span><span class="se">\\</span><span class="s2">square(S)/</span><span class="se">\\</span><span class="s2">in(T,S)</span>
<span class="o">---&gt;</span>
<span class="n">circle</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">/</span>\\<span class="ow">in</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
\\<span class="o">/</span>
<span class="ow">not</span><span class="p">(</span><span class="n">circle</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">/</span>\\<span class="ow">in</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="s2">&quot;).</span>
<span class="p">:</span><span class="o">-</span> <span class="n">end_in</span><span class="o">.</span>
</pre></div>
</div>
</section>
<section id="language-bias">
<h4>Language Bias<a class="headerlink" href="#language-bias" title="Permalink to this headline">¶</a></h4>
<p>The language bias part is specified by means of mode declarations in the style of <a class="reference external" href="https://www.doc.ic.ac.uk/~shm/progol.html">Progol</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modeh</span><span class="p">(</span><span class="o">&lt;</span><span class="n">recall</span><span class="o">&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="n">predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">arg1</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">))</span><span class="o">.</span>
</pre></div>
</div>
<p>specifies the atoms that can appear in the head of clauses, while</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modeb</span><span class="p">(</span><span class="o">&lt;</span><span class="n">recall</span><span class="o">&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="n">predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">arg1</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">))</span><span class="o">.</span>
</pre></div>
</div>
<p>specifies the atoms that can appear in the body of clauses. <code class="code docutils literal notranslate"><span class="pre">&lt;recall&gt;</span></code> can be an integer or <code class="code docutils literal notranslate"><span class="pre">*</span></code>.
<code class="code docutils literal notranslate"><span class="pre">&lt;recall&gt;</span></code> indicates how many atoms for the predicate specification are considered.
<code class="code docutils literal notranslate"><span class="pre">*</span></code> stands for all those that are found.
Otherwise the indicated number is randomly chosen.</p>
<p>Arguments of the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+&lt;</span><span class="nb">type</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>specifies that the argument should be an input variable of type <code class="code docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code>, i.e., a variable replacing a <code class="code docutils literal notranslate"><span class="pre">+&lt;type&gt;</span></code> argument in the head or a <code class="code docutils literal notranslate"><span class="pre">-&lt;type&gt;</span></code> argument in a preceding literal in the current hypothesized clause.</p>
<p>Another argument form is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-&lt;</span><span class="nb">type</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>for specifying that the argument should be a output variable of type <code class="code docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code>.
Any variable can replace this argument, either input or output.
The only constraint on output variables is that those in the head of the current hypothesized clause must appear as output variables in an atom of the body.</p>
<p>Other forms are</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#&lt;type&gt;</span>
</pre></div>
</div>
<p>for specifying an argument which should be replaced by a constant of type <code class="code docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">constant</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>for specifying a constant.</p>
<p>An example of language bias for the Bongard domain is</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">triangle</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">square</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">circle</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">in</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">in</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">in</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">config</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="s s-Atom">#dir</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">triangle</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">square</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">circle</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">in</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">in</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">config</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="s s-Atom">#dir</span><span class="p">)).</span>
</pre></div>
</div>
</section>
<section id="example-interpretations">
<h4>Example Interpretations<a class="headerlink" href="#example-interpretations" title="Permalink to this headline">¶</a></h4>
<p>The last part of the file contains the data.
You can specify data with two modalities: models and keys.
In the models type, you specify an example model (or interpretation or megaexample) as a list of Prolog facts initiated by <code class="code docutils literal notranslate"><span class="pre">begin(model(&lt;name&gt;)).</span></code> and terminated by <code class="code docutils literal notranslate"><span class="pre">end(model(&lt;name&gt;)).</span></code> as in</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">begin</span><span class="p">(</span><span class="nf">model</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span>
<span class="s s-Atom">pos</span><span class="p">.</span>
<span class="nf">triangle</span><span class="p">(</span><span class="s s-Atom">o5</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="s s-Atom">o5</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">square</span><span class="p">(</span><span class="s s-Atom">o4</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="s s-Atom">o4</span><span class="p">,</span><span class="s s-Atom">o5</span><span class="p">).</span>
<span class="nf">circle</span><span class="p">(</span><span class="s s-Atom">o3</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="s s-Atom">o2</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="s s-Atom">o2</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="s s-Atom">o2</span><span class="p">,</span><span class="s s-Atom">o3</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="s s-Atom">o1</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="s s-Atom">o1</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">end</span><span class="p">(</span><span class="nf">model</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span>
</pre></div>
</div>
<p>The facts in the interpretation are loaded in SWI-Prolog database by adding an extra initial argument equal to the name of the model.
After each interpretation is loaded, a fact of the form <code class="code docutils literal notranslate"><span class="pre">int(&lt;id&gt;)</span></code> is asserted, where <code class="code docutils literal notranslate"><span class="pre">id</span></code> is the name of the interpretation.
This can be used in order to retrieve the list of interpretations.</p>
<p>Alternatively, with the keys modality, you can directly write the facts and the first argument will be interpreted as a model identifier.
The above interpretation in the keys modality is</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">pos</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o5</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o5</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">square</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o4</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o4</span><span class="p">,</span><span class="s s-Atom">o5</span><span class="p">).</span>
<span class="nf">circle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o3</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o2</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o2</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o2</span><span class="p">,</span><span class="s s-Atom">o3</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o1</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o1</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
</pre></div>
</div>
<p>which is contained in the <a class="reference external" href="http://cplint.eu/e/bongardkeys.pl">bongardkeys.pl</a>.
This is also how model <code class="code docutils literal notranslate"><span class="pre">2</span></code> above is stored in SWI-Prolog database.
The two modalities, models and keys, can be mixed in the same file.
Facts for <code class="code docutils literal notranslate"><span class="pre">int/1</span></code> are not asserted for interpretations in the key modality but can be added by the user explicitly.</p>
<p>In order to specify if an interpretation is positive or negative, you should include in the interpretation a
fact. The form of the fact dependes on the parameter <code class="code docutils literal notranslate"><span class="pre">examples</span></code> whose values are <code class="code docutils literal notranslate"><span class="pre">{auto,</span> <span class="pre">keys(pred)}</span></code>. If set to <code class="code docutils literal notranslate"><span class="pre">auto</span></code>, positive examples in the models format should contain a <code class="code docutils literal notranslate"><span class="pre">pos</span></code> fact and in the keys format a <code class="code docutils literal notranslate"><span class="pre">pos(id)</span></code> fact, where <code class="code docutils literal notranslate"><span class="pre">id</span></code> is the identifier of the interpretation. If set to <code class="code docutils literal notranslate"><span class="pre">keys(pred)</span></code>, <code class="code docutils literal notranslate"><span class="pre">pred</span></code> or <code class="code docutils literal notranslate"><span class="pre">pred(pos)</span></code> (<code class="code docutils literal notranslate"><span class="pre">pred(id)</span></code> or <code class="code docutils literal notranslate"><span class="pre">pred(id,pos)</span></code> in the keys format) is used instead of <code class="code docutils literal notranslate"><span class="pre">pos</span></code> to determine positive exmples.</p>
<p>Then you must indicate how the examples are divided in folds with facts of the form: <code class="code docutils literal notranslate"><span class="pre">fold(&lt;fold_name&gt;,&lt;list</span> <span class="pre">of</span> <span class="pre">model</span> <span class="pre">identifiers&gt;)</span></code>, as for example</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">train</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,...]).</span>
<span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">test</span><span class="p">,[</span><span class="mi">490</span><span class="p">,</span><span class="mi">491</span><span class="p">,...]).</span>
</pre></div>
</div>
<p>As the input file is a Prolog program, you can define intensionally the folds as in</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">all</span><span class="p">,</span><span class="nv">F</span><span class="p">):-</span>
<span class="nf">findall</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="nf">int</span><span class="p">(</span><span class="nv">I</span><span class="p">),</span><span class="nv">F</span><span class="p">).</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">fold/2</span></code> is dynamic so you can also write (<a class="reference external" href="http://cplint.eu/e/registration.pl">registration.pl</a>)</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span>    <span class="p">:-</span> <span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">all</span><span class="p">,</span><span class="nv">F</span><span class="p">),</span>
            <span class="nf">sample</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="nv">F</span><span class="p">,</span><span class="nv">FTr</span><span class="p">,</span><span class="nv">FTe</span><span class="p">),</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">rand_train</span><span class="p">,</span><span class="nv">FTr</span><span class="p">)),</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">rand_test</span><span class="p">,</span><span class="nv">FTe</span><span class="p">)).</span>
</pre></div>
</div>
<p>which however must be inserted after the input interpretations otherwise the facts for <code class="code docutils literal notranslate"><span class="pre">int/1</span></code> will not be available and the fold <code class="code docutils literal notranslate"><span class="pre">all</span></code> would be empty.</p>
</section>
</section>
<section id="commands">
<h3>Commands<a class="headerlink" href="#commands" title="Permalink to this headline">¶</a></h3>
<section id="parameter-learning">
<h4>Parameter Learning<a class="headerlink" href="#parameter-learning" title="Permalink to this headline">¶</a></h4>
<p>To execute parameter learning, prepare an input file as indicated above and call</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce_par_pascal</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">list</span> <span class="s s-Atom">of</span> <span class="s s-Atom">folds&gt;</span><span class="p">,</span><span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">folds&gt;</span></code> is a list of the folds for training and <code class="code docutils literal notranslate"><span class="pre">T</span></code> will contain the input theory with updated parameters.</p>
<p>For example <a class="reference external" href="http://cplint.eu/e/pascal/bongardkeys.pl">bongardkeys.pl</a>, you can perform parameter learning on the <code class="code docutils literal notranslate"><span class="pre">train</span></code> fold with</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce_par_pascal</span><span class="p">([</span><span class="s s-Atom">train</span><span class="p">],</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
</section>
<section id="structure-learning">
<h4>Structure Learning<a class="headerlink" href="#structure-learning" title="Permalink to this headline">¶</a></h4>
<p>To execute structure learning, prepare an input file in the editor panel as indicated above and call</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">induce</span><span class="p">(</span><span class="o">+</span><span class="nv">List_of_folds</span><span class="s s-Atom">:list</span><span class="p">,</span><span class="o">-</span><span class="nv">T</span><span class="s s-Atom">:list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">List_of_folds</span></code> is a list of the folds for training and <code class="code docutils literal notranslate"><span class="pre">T</span></code> will contain the learned PCLT.</p>
<p>For example <a class="reference external" href="http://cplint.eu/e/pascal/bongardkeys.pl">bongardkeys.pl</a>, you can perform structure learning on the <code class="code docutils literal notranslate"><span class="pre">train</span></code> fold with</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce</span><span class="p">([</span><span class="s s-Atom">train</span><span class="p">],</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
<p>A PCLT can also be tested on a test set with <code class="code docutils literal notranslate"><span class="pre">test_pascal/7</span></code> or <code class="code docutils literal notranslate"><span class="pre">test_prob_pascal/6</span></code> as described below.</p>
</section>
<section id="testing">
<h4>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h4>
<p>A PCLT can also be tested on a test set with</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">test_pascal</span><span class="p">(</span><span class="o">+</span><span class="nv">T</span><span class="s s-Atom">:list</span><span class="p">,</span><span class="o">+</span><span class="nv">List_of_folds</span><span class="s s-Atom">:list</span><span class="p">,</span><span class="o">-</span><span class="nv">LL</span><span class="s s-Atom">:float</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCROC</span><span class="s s-Atom">:float</span><span class="p">,</span><span class="o">-</span><span class="nv">ROC</span><span class="s s-Atom">:list</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCPR</span><span class="s s-Atom">:float</span><span class="p">,</span><span class="o">-</span><span class="nv">PR</span><span class="s s-Atom">:list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_prob_pascal</span><span class="p">(</span><span class="o">+</span><span class="n">T</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span><span class="o">+</span><span class="n">List_of_folds</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span><span class="o">-</span><span class="n">NPos</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="o">-</span><span class="n">NNeg</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="o">-</span><span class="n">LL</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span><span class="o">-</span><span class="n">ExampleList</span><span class="p">:</span><span class="nb">list</span><span class="p">)</span> <span class="ow">is</span> <span class="n">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">T</span></code> is a list of terms representing clauses and <code class="code docutils literal notranslate"><span class="pre">List_of_folds</span></code> is a list of folds.</p>
<p><code class="code docutils literal notranslate"><span class="pre">test_pascal/7</span></code> returns the log likelihood of the test examples in <code class="code docutils literal notranslate"><span class="pre">LL</span></code>, the Area Under the ROC curve in <code class="code docutils literal notranslate"><span class="pre">AUCROC</span></code>, a dictionary containing the list of points (in the form of Prolog pairs <code class="code docutils literal notranslate"><span class="pre">x-y</span></code>) of the ROC curve in <code class="code docutils literal notranslate"><span class="pre">ROC</span></code>, the Area Under the PR curve in <code class="code docutils literal notranslate"><span class="pre">AUCPR</span></code>, a dictionary containing the list of points of the PR curve in <code class="code docutils literal notranslate"><span class="pre">PR</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">test_prob_pascal/6</span></code> returns the log likelihood of the test examples in <code class="code docutils literal notranslate"><span class="pre">LL</span></code>, the numbers of positive and negative examples in <code class="code docutils literal notranslate"><span class="pre">NPos</span></code> and <code class="code docutils literal notranslate"><span class="pre">NNeg</span></code> and the list <code class="code docutils literal notranslate"><span class="pre">ExampleList</span></code> containing couples <code class="code docutils literal notranslate"><span class="pre">Prob-Ex</span></code> where <code class="code docutils literal notranslate"><span class="pre">Ex</span></code> is <code class="code docutils literal notranslate"><span class="pre">a</span></code> for <code class="code docutils literal notranslate"><span class="pre">a</span></code> a positive example and <code class="code docutils literal notranslate"><span class="pre">\+(a)</span></code> for <code class="code docutils literal notranslate"><span class="pre">a</span></code> a negative example and <code class="code docutils literal notranslate"><span class="pre">Prob</span></code> is the probability of example <code class="code docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Then you can draw the curves in <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> on SWISH using C3.js using</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">compute_areas_diagrams</span><span class="p">(</span><span class="o">+</span><span class="n">ExampleList</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span><span class="o">-</span><span class="n">AUCROC</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span><span class="o">-</span><span class="n">ROC</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span><span class="o">-</span><span class="n">AUCPR</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span><span class="o">-</span><span class="n">PR</span><span class="p">:</span><span class="nb">dict</span><span class="p">)</span> <span class="ow">is</span> <span class="n">det</span>
</pre></div>
</div>
<p>(from pack <a class="reference external" href="http://www.swi-prolog.org/pack/list?p=auc">auc.pl</a>) that takes as input a list <code class="code docutils literal notranslate"><span class="pre">ExampleList</span></code> of pairs probability-literal of the form that is returned by <code class="code docutils literal notranslate"><span class="pre">test_prob_pascal/6</span></code>.</p>
<p>For example, to test on fold <code class="code docutils literal notranslate"><span class="pre">test</span></code> the program learned on fold <code class="code docutils literal notranslate"><span class="pre">train</span></code> you can run the query</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce_par</span><span class="p">([</span><span class="s s-Atom">train</span><span class="p">],</span><span class="nv">P</span><span class="p">),</span>
<span class="nf">test</span><span class="p">(</span><span class="nv">P</span><span class="p">,[</span><span class="s s-Atom">test</span><span class="p">],</span><span class="nv">LL</span><span class="p">,</span><span class="nv">AUCROC</span><span class="p">,</span><span class="nv">ROC</span><span class="p">,</span><span class="nv">AUCPR</span><span class="p">,</span><span class="nv">PR</span><span class="p">).</span>
</pre></div>
</div>
<p>Or you can test the input program on the fold <code class="code docutils literal notranslate"><span class="pre">test</span></code> with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span> <span class="n">code</span><span class="p">::</span> <span class="n">prolog</span>
</pre></div>
</div>
<blockquote>
<div><p>?- in(P),test(P,[test],LL,AUCROC,ROC,AUCPR,PR).</p>
</div></blockquote>
<p>In <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> on SWISH, by including</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span> <span class="n">code</span><span class="p">::</span> <span class="n">prolog</span>
</pre></div>
</div>
<blockquote>
<div><p>:- use_rendering(c3).
:- use_rendering(lpad).</p>
</div></blockquote>
<p>in the code before <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">pascal.</span></code> the curves will be shown as graphs using C3.js and the output program will be pretty printed.</p>
</section>
</section>
<section id="parameters-for-learning">
<h3>Parameters for Learning<a class="headerlink" href="#parameters-for-learning" title="Permalink to this headline">¶</a></h3>
<p>Parameters are set with commands of the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">:</span><span class="o">-</span> <span class="n">set_pascal</span><span class="p">(</span><span class="o">&lt;</span><span class="n">parameter</span><span class="o">&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>The available parameters are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">examples</span></code>: (values: <code class="code docutils literal notranslate"><span class="pre">{auto,</span> <span class="pre">keys(pred)}</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">auto</span></code>) if set to <code class="code docutils literal notranslate"><span class="pre">auto</span></code>, positive examples in the models format should contain a <code class="code docutils literal notranslate"><span class="pre">pos</span></code> fact and in the keys format a <code class="code docutils literal notranslate"><span class="pre">pos(id)</span></code> fact, where <code class="code docutils literal notranslate"><span class="pre">id</span></code> is the identifier of the interpretation. If set to <code class="code docutils literal notranslate"><span class="pre">keys(pred)</span></code>, <code class="code docutils literal notranslate"><span class="pre">pred</span></code> is used instead of <code class="code docutils literal notranslate"><span class="pre">pos</span></code> to determine positive exmples</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">beamsize</span></code> (values: integer, default value: 10): size of the beam</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">verbosity</span></code> (values: integer in [1,3], default value: 1): level of verbosity of the algorithms.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max_nodes</span></code> (values: integer, defualt value: 10): maximum number of iteration of beam search</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">optimal</span></code> (values: <code class="code docutils literal notranslate"><span class="pre">{yes,</span> <span class="pre">no}</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">no</span></code>): whether ther refinement operator is optimal or not</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max_length</span></code> (values: integer, defualt value: 4): maximum number of body literals and head disjuncts</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max_lengths</span></code> (values: list of integers <code class="code docutils literal notranslate"><span class="pre">[Body,Disjuncts,LitIn+,LitIn-]</span></code>, defualt value: <code class="code docutils literal notranslate"><span class="pre">[1,1,1,0]</span></code>): maximum number of, respectively, body literals, head disjuncts, literals in P disjuncts and literals in N disjuncts</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max_initial_weight</span></code> (values: real, default value <span class="math notranslate nohighlight">\(0.1)\)</span>: absolute value of the maximum of the initial weights in weight learning.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">learning_algorithm</span></code> (values: <code class="code docutils literal notranslate"><span class="pre">{gradient_descent,</span> <span class="pre">lbfgs}</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">gradient_descent</span></code>): algorithm for parameter learning</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">random_restarts_number</span></code> (values: integer, default value: 1): number of random restarts for gradient descent parameter learning</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">learning_rate</span></code> (values: <code class="code docutils literal notranslate"><span class="pre">{fixed(value),decay(eta_0,eta_tau,tau)}</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">fixed(0.01)</span></code>): value of the learning rate, either fixed to a value or set with a decay strategy</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">gd_iter</span></code> (values: integer, default value: 1000): maximum number of gradient descent iterations</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">epsilon</span></code> (values: real, default value: 0.0001): if the difference in the log likelihood in two successive parameter gradient descent iterations is smaller than <code class="code docutils literal notranslate"><span class="pre">epsilon</span></code>, then the algorithm stops</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">epsilon_fraction</span></code> (values: real, default value: 0.00001): if the difference in the log likelihood in two successive parameter gradient descent iterations is smaller than <code class="code docutils literal notranslate"><span class="pre">epsilon_fraction*(-current</span> <span class="pre">log</span> <span class="pre">likelihood)</span></code>, then the algorithm stops</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">regularization</span></code> (values: <code class="code docutils literal notranslate"><span class="pre">{1,2}</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">2</span></code>): either L1 or L2 regularization in gradient descent and lbfgs</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">regularizing_constant</span></code> (values: real, default value: 5): value of the regularizatiom constant in gradient descent and lbfgs</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max_rules</span></code> (values: integer, default value: 10): maximum number of PIC in the final theory</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">logzero</span></code> (values: negative real, default value <span class="math notranslate nohighlight">\(\log(0.01)\)</span>: value assigned to <span class="math notranslate nohighlight">\(\log(0)\)</span></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">zero</span></code> (values: positive real, default value <code class="code docutils literal notranslate"><span class="pre">0.0001</span></code>: value assigned to <span class="math notranslate nohighlight">\(0\)</span> when computing denominators that are counts</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">minus_infinity</span></code> (values: negative real, default value <code class="code docutils literal notranslate"><span class="pre">-1.0e20</span></code>: value assigned to <span class="math notranslate nohighlight">\(-\infty\)</span>, used as the intial value of the log likelihood in parameter learning</p></li>
</ul>
</section>
</section>
<section id="example-files">
<h2>Example Files<a class="headerlink" href="#example-files" title="Permalink to this headline">¶</a></h2>
<p>The <code class="code docutils literal notranslate"><span class="pre">pack/pascal/prolog/examples</span></code> folder in SWI-Prolog home contains some example programs.
The <code class="code docutils literal notranslate"><span class="pre">pack/pascal/docs</span></code> folder contains this manual in html and pdf.</p>
</section>
<section id="manual-in-pdf">
<h2>Manual in PDF<a class="headerlink" href="#manual-in-pdf" title="Permalink to this headline">¶</a></h2>
<p>A PDF version of the manual is available at <a class="reference external" href="http://friguzzi.github.io/pascal/_build/latex/pascal.pdf">http://friguzzi.github.io/pascal/_build/latex/pascal.pdf</a>.</p>
</section>
<section id="license">
<h2>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h2>
<p>Pascal follows the BSD 2-Clause License that you can find in the root folder.
The copyright is by Fabrizio Riguzzi.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="bibtex-bibliography-index-0"><dl class="citation">
<dt class="label" id="raelae95-alt95"><span class="brackets">DRVL95</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>L. De Raedt and W. Van Laer. Inductive constraint logic. In <em>Proceedings of the 6th Conference on Algorithmic Learning Theory (ALT 1995)</em>, volume 997 of LNAI, 80–94. Fukuoka, Japan, 1995. Springer.</p>
</dd>
<dt class="label" id="rigbelzesalblam21-ml-ij"><span class="brackets"><a class="fn-backref" href="#id1">RBZ+21</a></span></dt>
<dd><p>Fabrizio Riguzzi, Elena Bellodi, Riccardo Zese, Marco Alberti, and Evelina Lamma. Probabilistic inductive constraint logic. <em>Machine Learning</em>, 110:723–754, 2021. <a class="reference external" href="https://doi.org/10.1007/s10994-020-05911-6">doi:10.1007/s10994-020-05911-6</a>.</p>
</dd>
</dl>
</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Pascal Manual</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#example-of-use">Example of use</a></li>
<li><a class="reference internal" href="#testing-the-installation">Testing the installation</a></li>
<li><a class="reference internal" href="#support">Support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#language">Language</a></li>
<li><a class="reference internal" href="#use">Use</a><ul>
<li><a class="reference internal" href="#input">Input</a><ul>
<li><a class="reference internal" href="#preamble">Preamble</a></li>
<li><a class="reference internal" href="#background-and-initial-pclt">Background and Initial PCLT</a></li>
<li><a class="reference internal" href="#language-bias">Language Bias</a></li>
<li><a class="reference internal" href="#example-interpretations">Example Interpretations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#commands">Commands</a><ul>
<li><a class="reference internal" href="#parameter-learning">Parameter Learning</a></li>
<li><a class="reference internal" href="#structure-learning">Structure Learning</a></li>
<li><a class="reference internal" href="#testing">Testing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parameters-for-learning">Parameters for Learning</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-files">Example Files</a></li>
<li><a class="reference internal" href="#manual-in-pdf">Manual in PDF</a></li>
<li><a class="reference internal" href="#license">License</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="#">pascal 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Pascal Manual</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Riguzzi Fabrizio.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.1.
    </div>
  </body>
</html>