%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Pascal Documentation}
\date{Dec 23, 2021}
\release{1.0}
\author{Riguzzi Fabrizio}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{index:introduction}}
\sphinxAtStartPar
Pasccal is an algorithm for learning probabilistic integrity constraints. It was
proposed in \sphinxcite{index:belalbrig20-tplp-ij}.
It contains modules for both structure and parameter learning.

\sphinxAtStartPar
Pascal is also available in the cplint on SWISH web application at \sphinxurl{http://cplint.eu}.


\chapter{Installation}
\label{\detokenize{index:installation}}
\sphinxAtStartPar
Pascal is distributed as a \sphinxhref{http://www.swi-prolog.org/pack/list?p=pack}{pack} of \sphinxhref{http://www.swi-prolog.org/}{SWI\sphinxhyphen{}Prolog}.
To install it, use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{p}{:}\PYG{p}{:} \PYG{n}{prolog}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
?\sphinxhyphen{} pack\_install(pack).
\end{quote}


\section{Requirements}
\label{\detokenize{index:requirements}}
\sphinxAtStartPar
It requires the pack
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/friguzzi/lbfgs}{lbfgs}

\end{itemize}

\sphinxAtStartPar
It is installed automatically when installing pack \sphinxtitleref{pascal} or can be installed manually as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} swipl
?\PYGZhy{} pack\PYGZus{}install(lbfgs).
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxtitleref{lbfgs} uses a foreign library and contains the library binaries for 32 and 64 bits Linux. If you want to recompile the foreign library you can use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} pack\PYGZus{}rebuild(lbfgs).
\end{sphinxVerbatim}

\sphinxAtStartPar
On 32 and 64 bits Linux this should work out of the box.

\sphinxAtStartPar
You can upgrade the pack with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} swipl
?\PYGZhy{} pack\PYGZus{}upgrade(pack).
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the pack on which \sphinxtitleref{pascal} depends is not upgraded automatically in this case so it needs to be upgraded manually.


\section{Example of use}
\label{\detokenize{index:example-of-use}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZlt{}pack\PYGZgt{}/pascal/prolog/examples
\PYGZdl{} swipl
?\PYGZhy{} [bongardkeys].
?\PYGZhy{} induce\PYGZus{}pascal([train]),T).
\end{sphinxVerbatim}


\section{Testing the installation}
\label{\detokenize{index:testing-the-installation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} swipl
?\PYGZhy{} [library(test\PYGZus{}pascal)].
?\PYGZhy{} test\PYGZus{}pascal.
\end{sphinxVerbatim}


\section{Datasets}
\label{\detokenize{index:datasets}}
\sphinxAtStartPar
Other machine learning datasets are available in pack \sphinxhref{https://github.com/friguzzi/cplint\_datasets}{cplint\_datasets}.


\section{Support}
\label{\detokenize{index:support}}
\sphinxAtStartPar
Use the Google group \sphinxurl{https://groups.google.com/forum/\#!forum/cplint}.


\chapter{Language}
\label{\detokenize{index:language}}
\sphinxAtStartPar
A Probabilistic Constraint Logic Theory (PCLT) is a set of Probabilistic Integrity Constraints (PIC) of the form
\begin{equation*}
\begin{split}p \ ::\ L_1,\ldots,L_b\rightarrow \exists(P_1);\ldots;\exists(P_n);\forall\neg(N_1);\ldots;\forall\neg(N_m)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(p\) is a probability, each \(L_i\) is a literal and each \(P_j\) and \(N_j\) is a conjunction of literals.
We  call each \(P_j\)  a \sphinxstyleemphasis{P conjunction}  and  each \(N_k\) an
\sphinxstyleemphasis{N conjunction}.  We  call each
\(\exists(P_j)\) a \sphinxstyleemphasis{P disjunct} and each \(\forall\neg(N_k)\) an \sphinxstyleemphasis{N disjunct}.

\sphinxAtStartPar
The variables that occur in the body are quantified universally with
scope the PIC. The variables in the head that do not occur in the body
are quantified existentially if they occur in a P disjunct and
universally if they occur in an N disjunct, with scope the disjunct
they occur in.

\sphinxAtStartPar
An example of a PIC for the Bongard problems of \sphinxcite{index:raelae95-alt95}

\phantomsection\label{\detokenize{index:example-of-a-pic}}\begin{equation*}
\begin{split}0.5\ ::\ triangle(T),square(S),in(T,S)\rightarrow \exists(circle(C),in(C,S));\forall\neg(circle(C),in(C,T))\end{split}
\end{equation*}
\sphinxAtStartPar
which states
that if there is a triangle inside a square then either there exists a circle inside the square or
there doesn’t exist a circle inside the triangle. This constraint
has probability 0.5.


\chapter{Use}
\label{\detokenize{index:use}}
\sphinxAtStartPar
The following learning algorithms are available:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Parameter learning

\item {} 
\sphinxAtStartPar
Structure learning

\end{itemize}


\section{Input}
\label{\detokenize{index:input}}
\sphinxAtStartPar
To execute the learning algorithms, prepare a Prolog file divided in five parts
\begin{itemize}
\item {} 
\sphinxAtStartPar
preamble

\item {} 
\sphinxAtStartPar
background knowledge, i.e., knowledge valid for all interpretations

\item {} 
\sphinxAtStartPar
PCLT for you which you want to learn the parameters (optional)

\item {} 
\sphinxAtStartPar
language bias information

\item {} 
\sphinxAtStartPar
example interpretations

\end{itemize}

\sphinxAtStartPar
The preamble must come first, the order of the other parts can be changed.

\sphinxAtStartPar
For example, consider the Bongard problems of \sphinxcite{index:raelae95-alt95}.
\sphinxhref{http://cplint.eu/example/pascal/bongardkeys.pl}{bongardkeys.pl} represents a Bongard problem for Pascal.


\subsection{Preamble}
\label{\detokenize{index:preamble}}
\sphinxAtStartPar
In the preamble, the Pascal library is loaded with (\sphinxhref{http://cplint.eu/e/pascal/bongardkeys.pl}{bongardkeys.pl}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{n+nf}{library}\PYG{p}{(}\PYG{l+s+sAtom}{pascal}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now you can initialize pascal with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{pascal}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point you can start setting parameters for Pascal such as for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:\PYGZhy{}}\PYG{n+nf}{set\PYGZus{}pascal}\PYG{p}{(}\PYG{l+s+sAtom}{examples}\PYG{p}{,}\PYG{n+nf}{keys}\PYG{p}{(}\PYG{l+s+sAtom}{pos}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{p}{:\PYGZhy{}}\PYG{n+nf}{set\PYGZus{}pascal}\PYG{p}{(}\PYG{l+s+sAtom}{learning\PYGZus{}algorithm}\PYG{p}{,}\PYG{l+s+sAtom}{gradient\PYGZus{}descent}\PYG{p}{)}\PYG{p}{.}
\PYG{p}{:\PYGZhy{}}\PYG{n+nf}{set\PYGZus{}pascal}\PYG{p}{(}\PYG{l+s+sAtom}{learning\PYGZus{}rate}\PYG{p}{,}\PYG{n+nf}{fixed}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{p}{:\PYGZhy{}}\PYG{n+nf}{set\PYGZus{}pascal}\PYG{p}{(}\PYG{l+s+sAtom}{verbosity}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will see later the list of available parameters.

\sphinxAtStartPar
A parameter that is particularly important for Pascal is \sphinxcode{\sphinxupquote{verbosity}}: if set to 1,
nothing is printed and learning is fastest,
if set to 3 much information is printed and learning is slowest, 2 is in between. This ends the preamble.


\subsection{Background and Initial PCLT}
\label{\detokenize{index:background-and-initial-pclt}}
\sphinxAtStartPar
Now you can specify the background knowledge by including a set of Prolog clauses
in a section between \sphinxcode{\sphinxupquote{:\sphinxhyphen{} begin\_bg.}} and \sphinxcode{\sphinxupquote{:\sphinxhyphen{} end\_bg.}}
For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{begin\PYGZus{}bg}\PYG{p}{.}
\PYG{n+nf}{in}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,}\PYG{n+nv}{B}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{inside}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,}\PYG{n+nv}{B}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{in}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,}\PYG{n+nv}{D}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{inside}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,}\PYG{n+nv}{C}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{n+nv}{C}\PYG{p}{,}\PYG{n+nv}{D}\PYG{p}{)}\PYG{p}{.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{end\PYGZus{}bg}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Moreover, you can specify an initial PCLT in a section between \sphinxcode{\sphinxupquote{:\sphinxhyphen{} begin\_in.}} and \sphinxcode{\sphinxupquote{:\sphinxhyphen{} end\_in.}}.
The initial program is used in parameter learning for providing the structure.
In the section, facts for the predicates \sphinxcode{\sphinxupquote{rule/2}} or \sphinxcode{\sphinxupquote{ic/1}} can be given.

\sphinxAtStartPar
Facts for \sphinxcode{\sphinxupquote{rule/2}} take the form \sphinxcode{\sphinxupquote{rule(ic,prob)}} where \sphinxcode{\sphinxupquote{prob}} is a probability and
\sphinxcode{\sphinxupquote{ic}} is a term of the form \sphinxcode{\sphinxupquote{head:\sphinxhyphen{}body}}. In it, \sphinxcode{\sphinxupquote{body}} is a list of literals and \sphinxcode{\sphinxupquote{head}}
is a list of head disjuncts. Each head disjunct is couple \sphinxcode{\sphinxupquote{(sign,conjunction)}} where sign is
either \sphinxcode{\sphinxupquote{(+)}} for P disjuncts or \sphinxcode{\sphinxupquote{(\sphinxhyphen{})}} for N disjuncts and \sphinxcode{\sphinxupquote{conjunction}} is a list of literals.

\sphinxAtStartPar
The {\hyperref[\detokenize{index:example-of-a-pic}]{\sphinxcrossref{example of a PIC}}} above can be expressed as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{begin\PYGZus{}in}\PYG{p}{.}
\PYG{n+nf}{rule}\PYG{p}{(}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+sAtom}{+}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{n+nf}{circle}\PYG{p}{(}\PYG{n+nv}{C}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{n+nv}{C}\PYG{p}{,}\PYG{n+nv}{S}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZhy{}}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{n+nf}{circle}\PYG{p}{(}\PYG{n+nv}{C}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{n+nv}{C}\PYG{p}{,}\PYG{n+nv}{T}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}\PYG{p}{:\PYGZhy{}}
  \PYG{p}{[}\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{n+nv}{T}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nv}{S}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{n+nv}{T}\PYG{p}{,}\PYG{n+nv}{S}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{end\PYGZus{}in}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Facts for the predicate \sphinxcode{\sphinxupquote{ic/1}} take the form \sphinxcode{\sphinxupquote{ic(string)}} where \sphinxcode{\sphinxupquote{string}} is a Prolog
string wher a constraint is encoded as \sphinxcode{\sphinxupquote{prob::body\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}\textgreater{}head}}.
\sphinxcode{\sphinxupquote{body}} is a conjuntion of literals where the conjunction symbol is \sphinxcode{\sphinxupquote{/\textbackslash{} }}.
\sphinxcode{\sphinxupquote{head}} is a disjunction where the disjunction symbol is \sphinxcode{\sphinxupquote{\textbackslash{}/}}.
Each disjunct is either a conjunction of literals, in the case of a P disjunct, or of the form
\sphinxcode{\sphinxupquote{not(conjunction)}} where \sphinxcode{\sphinxupquote{conjunction}} is a conjunction of literals.

\sphinxAtStartPar
The {\hyperref[\detokenize{index:example-of-a-pic}]{\sphinxcrossref{example of a PIC}}} above can be expressed as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{begin\PYGZus{}in}\PYG{o}{.}
\PYG{n}{ic}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.5 :: triangle(T)/}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{square(S)/}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{in(T,S)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}
\PYG{n}{circle}\PYG{p}{(}\PYG{n}{C}\PYG{p}{)}\PYG{o}{/}\PYGZbs{}\PYGZbs{}\PYG{o+ow}{in}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,}\PYG{n}{S}\PYG{p}{)}
\PYGZbs{}\PYGZbs{}\PYG{o}{/}
\PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{circle}\PYG{p}{(}\PYG{n}{C}\PYG{p}{)}\PYG{o}{/}\PYGZbs{}\PYGZbs{}\PYG{o+ow}{in}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,}\PYG{n}{T}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{).}
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{end\PYGZus{}in}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Language Bias}
\label{\detokenize{index:language-bias}}
\sphinxAtStartPar
The language bias part is specified by means of mode declarations in the style of \sphinxhref{https://www.doc.ic.ac.uk/~shm/progol.html}{Progol}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{modeh}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{recall}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{predicate}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{arg1}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
specifies the atoms that can appear in the head of clauses, while

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{modeb}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{recall}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{predicate}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{arg1}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
specifies the atoms that can appear in the body of clauses. \sphinxcode{\sphinxupquote{\textless{}recall\textgreater{}}} can be an integer or \sphinxcode{\sphinxupquote{*}}.
\sphinxcode{\sphinxupquote{\textless{}recall\textgreater{}}} indicates how many atoms for the predicate specification are considered.
\sphinxcode{\sphinxupquote{*}} stands for all those that are found.
Otherwise the indicated number is randomly chosen.

\sphinxAtStartPar
Arguments of the form

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{+}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
specifies that the argument should be an input variable of type \sphinxcode{\sphinxupquote{\textless{}type\textgreater{}}}, i.e., a variable replacing a \sphinxcode{\sphinxupquote{+\textless{}type\textgreater{}}} argument in the head or a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\textless{}type\textgreater{}}} argument in a preceding literal in the current hypothesized clause.

\sphinxAtStartPar
Another argument form is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
for specifying that the argument should be a output variable of type \sphinxcode{\sphinxupquote{\textless{}type\textgreater{}}}.
Any variable can replace this argument, either input or output.
The only constraint on output variables is that those in the head of the current hypothesized clause must appear as output variables in an atom of the body.

\sphinxAtStartPar
Other forms are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZlt{}type\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
for specifying an argument which should be replaced by a constant of type \sphinxcode{\sphinxupquote{\textless{}type\textgreater{}}} in the bottom clause but should not be used for replacing input variables of the following literals when building the bottom clause or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{c+c1}{\PYGZsh{}\PYGZlt{}type\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
for specifying an argument which should be replaced by a constant of type \sphinxcode{\sphinxupquote{\textless{}type\textgreater{}}} in the bottom clause and that should be used for replacing input variables of the following literals when building the bottom clause.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{constant}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
for specifying a constant.

\sphinxAtStartPar
An example of language bias for the Bongard domain is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{modeh}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeh}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{square}\PYG{p}{(}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeh}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{circle}\PYG{p}{(}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeh}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeh}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+s+sAtom}{obj}\PYG{p}{,}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeh}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{,}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeh}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{config}\PYG{p}{(}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{,}\PYG{l+s+sAtom}{\PYGZhy{}\PYGZsh{}}\PYG{l+s+sAtom}{dir}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeb}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeb}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{square}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeb}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{circle}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeb}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeb}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{in}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+s+sAtom}{obj}\PYG{p}{,}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{modeb}\PYG{p}{(}\PYG{l+s+sAtom}{*}\PYG{p}{,}\PYG{n+nf}{config}\PYG{p}{(}\PYG{o}{+}\PYG{l+s+sAtom}{obj}\PYG{p}{,}\PYG{l+s+sAtom}{\PYGZhy{}\PYGZsh{}}\PYG{l+s+sAtom}{dir}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}


\subsection{Example Interpretations}
\label{\detokenize{index:example-interpretations}}
\sphinxAtStartPar
The last part of the file contains the data.
You can specify data with two modalities: models and keys.
In the models type, you specify an example model (or interpretation or megaexample) as a list of Prolog facts initiated by \sphinxcode{\sphinxupquote{begin(model(\textless{}name\textgreater{})).}} and terminated by \sphinxcode{\sphinxupquote{end(model(\textless{}name\textgreater{})).}} as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{begin}\PYG{p}{(}\PYG{n+nf}{model}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\PYG{l+s+sAtom}{pos}\PYG{p}{.}
\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{l+s+sAtom}{o5}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{config}\PYG{p}{(}\PYG{l+s+sAtom}{o5}\PYG{p}{,}\PYG{l+s+sAtom}{up}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+s+sAtom}{o4}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{in}\PYG{p}{(}\PYG{l+s+sAtom}{o4}\PYG{p}{,}\PYG{l+s+sAtom}{o5}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{circle}\PYG{p}{(}\PYG{l+s+sAtom}{o3}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{l+s+sAtom}{o2}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{config}\PYG{p}{(}\PYG{l+s+sAtom}{o2}\PYG{p}{,}\PYG{l+s+sAtom}{up}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{in}\PYG{p}{(}\PYG{l+s+sAtom}{o2}\PYG{p}{,}\PYG{l+s+sAtom}{o3}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{l+s+sAtom}{o1}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{config}\PYG{p}{(}\PYG{l+s+sAtom}{o1}\PYG{p}{,}\PYG{l+s+sAtom}{up}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{end}\PYG{p}{(}\PYG{n+nf}{model}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The facts in the interpretation are loaded in SWI\sphinxhyphen{}Prolog database by adding an extra initial argument equal to the name of the model.
After each interpretation is loaded, a fact of the form \sphinxcode{\sphinxupquote{int(\textless{}id\textgreater{})}} is asserted, where \sphinxcode{\sphinxupquote{id}} is the name of the interpretation.
This can be used in order to retrieve the list of interpretations.

\sphinxAtStartPar
Alternatively, with the keys modality, you can directly write the facts and the first argument will be interpreted as a model identifier.
The above interpretation in the keys modality is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{pos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o5}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{config}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o5}\PYG{p}{,}\PYG{l+s+sAtom}{up}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o4}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{in}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o4}\PYG{p}{,}\PYG{l+s+sAtom}{o5}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{circle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o3}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o2}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{config}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o2}\PYG{p}{,}\PYG{l+s+sAtom}{up}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{in}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o2}\PYG{p}{,}\PYG{l+s+sAtom}{o3}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{triangle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o1}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{config}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+sAtom}{o1}\PYG{p}{,}\PYG{l+s+sAtom}{up}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
which is contained in the \sphinxhref{http://cplint.eu/e/bongardkeys.pl}{bongardkeys.pl}.
This is also how model \sphinxcode{\sphinxupquote{2}} above is stored in SWI\sphinxhyphen{}Prolog database.
The two modalities, models and keys, can be mixed in the same file.
Facts for \sphinxcode{\sphinxupquote{int/1}} are not asserted for interpretations in the key modality but can be added by the user explicitly.

\sphinxAtStartPar
Then you must indicate how the examples are divided in folds with facts of the form: \sphinxcode{\sphinxupquote{fold(\textless{}fold\_name\textgreater{},\textless{}list of model identifiers\textgreater{})}}, as for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{fold}\PYG{p}{(}\PYG{l+s+sAtom}{train}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{.}
\PYG{n+nf}{fold}\PYG{p}{(}\PYG{l+s+sAtom}{test}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{490}\PYG{p}{,}\PYG{l+m+mi}{491}\PYG{p}{,}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
As the input file is a Prolog program, you can define intensionally the folds as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{fold}\PYG{p}{(}\PYG{l+s+sAtom}{all}\PYG{p}{,}\PYG{n+nv}{F}\PYG{p}{)}\PYG{p}{:\PYGZhy{}}
\PYG{n+nf}{findall}\PYG{p}{(}\PYG{n+nv}{I}\PYG{p}{,}\PYG{n+nf}{int}\PYG{p}{(}\PYG{n+nv}{I}\PYG{p}{)}\PYG{p}{,}\PYG{n+nv}{F}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fold/2}} is dynamic so you can also write (\sphinxhref{http://cplint.eu/e/registration.pl}{registration.pl})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{fold}\PYG{p}{(}\PYG{l+s+sAtom}{all}\PYG{p}{,}\PYG{n+nv}{F}\PYG{p}{)}\PYG{p}{,}
            \PYG{n+nf}{sample}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n+nv}{F}\PYG{p}{,}\PYG{n+nv}{FTr}\PYG{p}{,}\PYG{n+nv}{FTe}\PYG{p}{)}\PYG{p}{,}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{n+nf}{fold}\PYG{p}{(}\PYG{l+s+sAtom}{rand\PYGZus{}train}\PYG{p}{,}\PYG{n+nv}{FTr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{n+nf}{fold}\PYG{p}{(}\PYG{l+s+sAtom}{rand\PYGZus{}test}\PYG{p}{,}\PYG{n+nv}{FTe}\PYG{p}{)}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
which however must be inserted after the input interpretations otherwise the facts for \sphinxcode{\sphinxupquote{int/1}} will not be available and the fold \sphinxcode{\sphinxupquote{all}} would be empty.


\section{Commands}
\label{\detokenize{index:commands}}

\subsection{Parameter Learning}
\label{\detokenize{index:parameter-learning}}
\sphinxAtStartPar
To execute parameter learning, prepare an input file as indicated above and call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sAtom}{?\PYGZhy{}} \PYG{n+nf}{induce\PYGZus{}par\PYGZus{}pascal}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{l+s+sAtom}{list} \PYG{l+s+sAtom}{of} \PYG{l+s+sAtom}{folds}\PYG{l+s+sAtom}{\PYGZgt{}}\PYG{p}{,}\PYG{n+nv}{T}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{\textless{}list of folds\textgreater{}}} is a list of the folds for training and \sphinxcode{\sphinxupquote{T}} will contain the input theory with updated parameters.

\sphinxAtStartPar
For example \sphinxhref{http://cplint.eu/e/pascal/bongardkeys.pl}{bongardkeys.pl}, you can perform parameter learning on the \sphinxcode{\sphinxupquote{train}} fold with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sAtom}{?\PYGZhy{}} \PYG{n+nf}{induce\PYGZus{}par\PYGZus{}pascal}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+sAtom}{train}\PYG{p}{]}\PYG{p}{,}\PYG{n+nv}{P}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}


\subsection{Structure Learning}
\label{\detokenize{index:structure-learning}}
\sphinxAtStartPar
To execute structure learning, prepare an input file in the editor panel as indicated above and call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{induce}\PYG{p}{(}\PYG{o}{+}\PYG{n+nv}{List\PYGZus{}of\PYGZus{}folds}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{list}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{T}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{list}\PYG{p}{)} \PYG{o}{is} \PYG{l+s+sAtom}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{List\_of\_folds}} is a list of the folds for training and \sphinxcode{\sphinxupquote{T}} will contain the learned PCLT.

\sphinxAtStartPar
For example \sphinxhref{http://cplint.eu/e/pascal/bongardkeys.pl}{bongardkeys.pl}, you can perform structure learning on the \sphinxcode{\sphinxupquote{train}} fold with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sAtom}{?\PYGZhy{}} \PYG{n+nf}{induce}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+sAtom}{train}\PYG{p}{]}\PYG{p}{,}\PYG{n+nv}{P}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
A PCLT can also be tested on a test set with \sphinxcode{\sphinxupquote{test\_pascal/7}} or \sphinxcode{\sphinxupquote{test\_prob\_pascal/6}} as described below.


\subsection{Testing}
\label{\detokenize{index:testing}}
\sphinxAtStartPar
A PCLT can also be tested on a test set with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{test\PYGZus{}pascal}\PYG{p}{(}\PYG{o}{+}\PYG{n+nv}{T}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{list}\PYG{p}{,}\PYG{o}{+}\PYG{n+nv}{List\PYGZus{}of\PYGZus{}folds}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{list}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{LL}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{AUCROC}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{ROC}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{list}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{AUCPR}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{PR}\PYG{l+s+sAtom}{:}\PYG{l+s+sAtom}{list}\PYG{p}{)} \PYG{o}{is} \PYG{l+s+sAtom}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test\PYGZus{}prob\PYGZus{}pascal}\PYG{p}{(}\PYG{o}{+}\PYG{n}{T}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{,}\PYG{o}{+}\PYG{n}{List\PYGZus{}of\PYGZus{}folds}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{NPos}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{NNeg}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{LL}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{ExampleList}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{T}} is a list of terms representing clauses and \sphinxcode{\sphinxupquote{List\_of\_folds}} is a list of folds.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{test\_pascal/7}} returns the log likelihood of the test examples in \sphinxcode{\sphinxupquote{LL}}, the Area Under the ROC curve in \sphinxcode{\sphinxupquote{AUCROC}}, a dictionary containing the list of points (in the form of Prolog pairs \sphinxcode{\sphinxupquote{x\sphinxhyphen{}y}}) of the ROC curve in \sphinxcode{\sphinxupquote{ROC}}, the Area Under the PR curve in \sphinxcode{\sphinxupquote{AUCPR}}, a dictionary containing the list of points of the PR curve in \sphinxcode{\sphinxupquote{PR}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{test\_prob\_pascal/6}} returns the log likelihood of the test examples in \sphinxcode{\sphinxupquote{LL}}, the numbers of positive and negative examples in \sphinxcode{\sphinxupquote{NPos}} and \sphinxcode{\sphinxupquote{NNeg}} and the list \sphinxcode{\sphinxupquote{ExampleList}} containing couples \sphinxcode{\sphinxupquote{Prob\sphinxhyphen{}Ex}} where \sphinxcode{\sphinxupquote{Ex}} is \sphinxcode{\sphinxupquote{a}} for \sphinxcode{\sphinxupquote{a}} a positive example and \sphinxcode{\sphinxupquote{\textbackslash{}+(a)}} for \sphinxcode{\sphinxupquote{a}} a negative example and \sphinxcode{\sphinxupquote{Prob}} is the probability of example \sphinxcode{\sphinxupquote{a}}.

\sphinxAtStartPar
Then you can draw the curves in \sphinxcode{\sphinxupquote{cplint}} on SWISH using C3.js using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compute\PYGZus{}areas\PYGZus{}diagrams}\PYG{p}{(}\PYG{o}{+}\PYG{n}{ExampleList}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{AUCROC}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{ROC}\PYG{p}{:}\PYG{n+nb}{dict}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{AUCPR}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{PR}\PYG{p}{:}\PYG{n+nb}{dict}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
(from pack \sphinxhref{http://www.swi-prolog.org/pack/list?p=auc}{auc.pl}) that takes as input a list \sphinxcode{\sphinxupquote{ExampleList}} of pairs probability\sphinxhyphen{}literal of the form that is returned by \sphinxcode{\sphinxupquote{test\_prob\_pascal/6}}.

\sphinxAtStartPar
For example, to test on fold \sphinxcode{\sphinxupquote{test}} the program learned on fold \sphinxcode{\sphinxupquote{train}} you can run the query

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sAtom}{?\PYGZhy{}} \PYG{n+nf}{induce\PYGZus{}par}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+sAtom}{train}\PYG{p}{]}\PYG{p}{,}\PYG{n+nv}{P}\PYG{p}{)}\PYG{p}{,}
\PYG{n+nf}{test}\PYG{p}{(}\PYG{n+nv}{P}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+sAtom}{test}\PYG{p}{]}\PYG{p}{,}\PYG{n+nv}{LL}\PYG{p}{,}\PYG{n+nv}{AUCROC}\PYG{p}{,}\PYG{n+nv}{ROC}\PYG{p}{,}\PYG{n+nv}{AUCPR}\PYG{p}{,}\PYG{n+nv}{PR}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or you can test the input program on the fold \sphinxcode{\sphinxupquote{test}} with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{p}{:}\PYG{p}{:} \PYG{n}{prolog}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
?\sphinxhyphen{} in(P),test(P,{[}test{]},LL,AUCROC,ROC,AUCPR,PR).
\end{quote}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{cplint}} on SWISH, by including

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{p}{:}\PYG{p}{:} \PYG{n}{prolog}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
:\sphinxhyphen{} use\_rendering(c3).
:\sphinxhyphen{} use\_rendering(lpad).
\end{quote}

\sphinxAtStartPar
in the code before \sphinxcode{\sphinxupquote{:\sphinxhyphen{} pascal.}} the curves will be shown as graphs using C3.js and the output program will be pretty printed.


\section{Parameters for Learning}
\label{\detokenize{index:parameters-for-learning}}
\sphinxAtStartPar
Parameters are set with commands of the form

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{set\PYGZus{}pascal}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{value}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The available parameters are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{specialization}}: (values: \sphinxcode{\sphinxupquote{\{bottom,mode\}}}, default value: \sphinxcode{\sphinxupquote{bottom}}, valid for SLIPCOVER) specialization mode.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{depth\_bound}}: (values: \sphinxcode{\sphinxupquote{\{true,false\}}}, default value: \sphinxcode{\sphinxupquote{true}}) if \sphinxcode{\sphinxupquote{true}}, the depth of the derivation of the goal is limited to the value of the \sphinxcode{\sphinxupquote{depth}} parameter.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{depth}} (values: integer, default value: 2): depth of derivations if \sphinxcode{\sphinxupquote{depth\_bound}} is set to \sphinxcode{\sphinxupquote{true}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{single\_var}} (values: \sphinxcode{\sphinxupquote{\{true,false\}}}, default value: \sphinxcode{\sphinxupquote{false}}): if set to \sphinxcode{\sphinxupquote{true}}, there is a random variable for each clause, instead of a different random variable for each grounding of each clause

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{epsilon\_em}} (values: real, default value: 0.1): if the difference in the log likelihood in two successive parameter EM iteration is smaller than \sphinxcode{\sphinxupquote{epsilon\_em}}, then EM stops

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{epsilon\_em\_fraction}} (values: real, default value: 0.01): if the difference in the log likelihood in two successive parameter EM iteration is smaller than \sphinxcode{\sphinxupquote{epsilon\_em\_fraction*(\sphinxhyphen{}current log likelihood)}}, then EM stops

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iter}} (values: integer, defualt value: 1): maximum number of iteration of EM parameter learning. If set to \sphinxhyphen{}1, no maximum number of iterations is imposed

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iterREF}} (values: integer, defualt value: 1, valid for SLIPCOVER and LEMUR): maximum number of iteration of EM parameter learning for refinements. If set to \sphinxhyphen{}1, no maximum number of iterations is imposed.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{random\_restarts\_number}} (values: integer, default value: 1, valid for EMBLEM, SLIPCOVER and LEMUR): number of random restarts of parameter EM learning

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{random\_restarts\_REFnumber}} (values: integer, default value: 1, valid for SLIPCOVER and LEMUR): number of random restarts of parameter EM learning for refinements

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{seed}} (values: seed(integer) or seed(random), default value \sphinxcode{\sphinxupquote{seed(3032)}}): seed for the Prolog random functions, see \sphinxhref{http://www.swi-prolog.org/pldoc/man?predicate=set\_random/1}{SWI\sphinxhyphen{}Prolog manual}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c\_seed}} (values: unsigned integer, default value 21344)): seed for the C random functions

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logzero}} (values: negative real, default value \(\log(0.000001)\): value assigned to \(\log(0)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_iter}} (values: integer, default value: 10, valid for SLIPCOVER): number of interations of beam search

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_var}} (values: integer, default value: 4, valid for SLIPCOVER and LEMUR): maximum number of distinct variables in a clause

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{beamsize}} (values: integer, default value: 100, valid for SLIPCOVER): size of the beam

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{megaex\_bottom}} (values: integer, default value: 1, valid for SLIPCOVER): number of mega\sphinxhyphen{}examples on which to build the bottom clauses

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{initial\_clauses\_per\_megaex}} (values: integer, default value: 1, valid for SLIPCOVER): number of bottom clauses to build for each mega\sphinxhyphen{}example (or model or interpretation)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{d}} (values: integer, default value: 1, valid for SLIPCOVER): number of saturation steps when building the bottom clause

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcts\_beamsize}} (values: integer, default value: 3, valid for LEMUR): size of the Monte\sphinxhyphen{}Carlo tree search beam

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcts\_visits}} (values: integer, default value: +1e20, valid for LEMUR): maximum number of visits

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_iter\_structure}} (values: integer, default value: 10000, valid for SLIPCOVER): maximum number of theory search iterations

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcts\_max\_depth}} (values: integer, default value: 8, valid for LEMUR): maximum depth of default policy search

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcts\_c}} (values: real, default value: 0.7, valid for LEMUR): value of parameter \(C\) in the computation of UCT

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcts\_iter}} (values: integer, default value: 20, valid for LEMUR): number of Monte\sphinxhyphen{}Carlo tree search iterations

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mcts\_maxrestarts}} (values: integer, default value: 20, valid for LEMUR): maximum number of Monte\sphinxhyphen{}Carlo tree search restarts

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{neg\_ex}} (values: \sphinxcode{\sphinxupquote{given}}, \sphinxcode{\sphinxupquote{cw}}, default value: \sphinxcode{\sphinxupquote{cw}}): if set to \sphinxcode{\sphinxupquote{given}}, the negative examples in training and testing are taken from the test folds interpretations, i.e., those examples \sphinxcode{\sphinxupquote{ex}} stored as \sphinxcode{\sphinxupquote{neg(ex)}}; if set to \sphinxcode{\sphinxupquote{cw}}, the negative examples in training and testing are generated according to the closed world assumption, i.e., all atoms for target predicates that are not positive examples. The set of all atoms is obtained by collecting the set of constants for each type of the arguments of the target predicate, so the target predicates must have at least one fact for \sphinxcode{\sphinxupquote{modeh/2}} or \sphinxcode{\sphinxupquote{modebb/2}} also for parameter learning.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{alpha}} (values: floating point \(\geq 0\), default value: 0): parameter of the symmetric Dirichlet distribution used to initialize the parameters. If it takes value 0, a truncated Dirichlet process is used to sample parameters: the probability of being true of each Boolean random variable used to represent multivalued random variables is sampled uniformly and independently in {[}0,1{]}. If it takes a value \(\geq 0\), the parameters are sampled from a symmetric Dirichlet distribution, i.e. a Dirichlet distribution with vector of parameters \(\alpha,\ldots,\alpha\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{verbosity}} (values: integer in {[}1,3{]}, default value: 1): level of verbosity of the algorithms.

\end{itemize}


\chapter{Example Files}
\label{\detokenize{index:example-files}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{pack/pascal/prolog/examples}} folder in SWI\sphinxhyphen{}Prolog home contains some example programs.
The \sphinxcode{\sphinxupquote{pack/pascal/docs}} folder contains this manual in latex, html and pdf.


\chapter{Manual in PDF}
\label{\detokenize{index:manual-in-pdf}}
\sphinxAtStartPar
A PDF version of the manual is available at \sphinxurl{http://friguzzi.github.io/pascal/\_build/latex/pascal.pdf}.


\chapter{License}
\label{\detokenize{index:license}}
\sphinxAtStartPar
Pascal follows the BSD 2\sphinxhyphen{}Clause License that you can find in the root folder.
The copyright is by Fabrizio Riguzzi.


\chapter{References}
\label{\detokenize{index:references}}
\sphinxAtStartPar


\begin{sphinxthebibliography}{BARZ20}
\bibitem[BARZ20]{index:belalbrig20-tplp-ij}
\sphinxAtStartPar
Elena Bellodi, Marco Alberti, Fabrizio Riguzzi, and Riccardo Zese. MAP inference for probabilistic logic programming. \sphinxstyleemphasis{Theory and Practice of Logic Programming}, 20(5):641\textendash{}655, 2020. URL: \sphinxurl{https://arxiv.org/abs/2008.01394}, \sphinxhref{https://doi.org/10.1017/S1471068420000174}{doi:10.1017/S1471068420000174}.
\bibitem[DRVL95]{index:raelae95-alt95}
\sphinxAtStartPar
L. De Raedt and W. Van Laer. Inductive constraint logic. In \sphinxstyleemphasis{Proceedings of the 6th Conference on Algorithmic Learning Theory (ALT 1995)}, volume 997 of LNAI, 80\textendash{}94. Fukuoka, Japan, 1995. Springer.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}